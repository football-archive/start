---
// src/components/MatchScheduleTable.astro
import type { MatchRow } from "../lib/competitionSchedule";
import { formatScore, isPlayed } from "../lib/competitionSchedule";

type Props = {
  matches: MatchRow[];
  heading?: string;
  /** 内部スクロールにしたいなら true（デフォルトtrue） */
  scroll?: boolean;
  /** scroll=true のときの高さ */
  maxHeight?: number;
};

const {
  matches,
  heading = "日程・結果",
  scroll = true,
  maxHeight = 560,
} = Astro.props;

// stage順（好みで追加/調整OK）
const stageOrder = [
  "Playoff",
  "Group-Phase",
  "Round32",
  "Round16",
  "Quarterfinals",
  "Semifinals",
  "Third-place",
  "Final",
  "Other",
];

const byStage = new Map<string, MatchRow[]>();
for (const m of matches) {
  const key = String(m.stage || "Other").trim() || "Other";
  if (!byStage.has(key)) byStage.set(key, []);
  byStage.get(key)!.push(m);
}

const stages = [...byStage.keys()].sort((a, b) => {
  const ia = stageOrder.indexOf(a);
  const ib = stageOrder.indexOf(b);
  return (ia === -1 ? 999 : ia) - (ib === -1 ? 999 : ib);
});

// 1つのtableに「ステージ区切り行」を挟む
type RowItem =
  | { kind: "stage"; stage: string }
  | { kind: "match"; m: MatchRow };

const rows: RowItem[] = [];
for (const st of stages) {
  rows.push({ kind: "stage", stage: st });
  const list = byStage.get(st) || [];
  for (const m of list) rows.push({ kind: "match", m });
}
---

<section id="schedule" class="match-schedule" style="margin: 18px 0;">

  {
    /*
  <h2>{heading}</h2>
  <p class="quick-title" style="margin: 6px 0 10px;">
    縦に全試合を一覧表示（スコアが入ると自動で結果表示）
  </p>
*/
  }

  <div
    class:list={["matches-wrap", scroll ? "is-scroll" : ""]}
    style={scroll ? `max-height:${maxHeight}px;` : ""}
  >
    <table class="schedule">
      <thead>
        <tr>
          <th class="col-dt">日時</th>
          <th class="col-sec">節</th>
          <th class="col-gr">Grp</th>
          <th>対戦</th>
          <th class="col-score">結果</th>
          <th class="col-st">会場</th>
        </tr>
      </thead>

      <tbody>
        {
          rows.map((r) => {
            if (r.kind === "stage") {
              return (
                <tr class="stage-row">
                  <td colSpan={6}>
                    <span class="stage-label">{r.stage}</span>
                  </td>
                </tr>
              );
            }

            const m = r.m;
            return (
              <tr class={isPlayed(m) ? "played" : ""}>
                <td class="col-dt">{(m as any)["datetimeLocal"]}</td>
                <td class="col-sec">{(m as any).sec || "—"}</td>
                {/* ✅ “G”は付けずに A/B/... だけ */}
                <td class="col-gr">
                  {(m as any).group ? `${(m as any).group}` : "—"}
                </td>

                {/* ✅ home / vs / away を揃える */}
                <td class="col-match">
                  <span class="team home">{(m as any).home}</span>
                  <span class="vs">vs</span>
                  <span class="team away">{(m as any).away}</span>
                </td>

                <td class="col-score">
                  <b>{formatScore(m)}</b>
                </td>

                <td class="col-st">{(m as any).stadium || "—"}</td>
              </tr>
            );
          })
        }
      </tbody>
    </table>
  </div>
</section>

<style is:global>
  /* ========= MatchScheduleTable (scoped by .match-schedule) ========= */

  .match-schedule .matches-wrap {
    border: 1px solid var(--border, #e6e6e6);
    border-radius: 14px;
    background: #fff;
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
  }

  /* 内部スクロールしたい場合だけ縦スクロール */
  .match-schedule .matches-wrap.is-scroll {
    overflow-y: auto;
  }

  .match-schedule table.schedule {
    width: 100%;
    table-layout: fixed;
    border-collapse: separate;
    border-spacing: 0;
  }

  .match-schedule table.schedule th,
  .match-schedule table.schedule td {
    border-top: 1px solid var(--border, #e6e6e6);
    padding: 10px 12px;
    font-size: 13px;
    vertical-align: middle;
    background: #fff;
    text-align: center;
    white-space: nowrap;
  }

  /* sticky header */
  .match-schedule table.schedule thead th {
    position: sticky;
    top: 0;
    z-index: 3;
    background: #f7fbff;
    color: #2563eb;
    font-weight: 800;
    border-top: none;
    border-bottom: 1px solid var(--border, #e6e6e6);
  }

  /* 列幅 */
  .match-schedule .col-dt {
    width: 120px;
    font-variant-numeric: tabular-nums;
  }
  .match-schedule .col-sec {
    width: 70px;
  }
  .match-schedule .col-gr {
    width: 70px;
  }
  .match-schedule .col-score {
    width: 110px;
    font-variant-numeric: tabular-nums;
    text-align: center;
  }
  .match-schedule .col-st {
    width: 240px;
  }

  /* 対戦セル */
  .match-schedule td.col-match {
    display: grid;
    grid-template-columns: 1fr 34px 1fr;
    align-items: center;
    gap: 6px;
  }
  .match-schedule td.col-match .team {
    font-weight: 700;
  }
  .match-schedule td.col-match .team.home {
    text-align: right;
  }
  .match-schedule td.col-match .vs {
    text-align: center;
    color: var(--muted, #666);
    font-size: 12px;
  }
  .match-schedule td.col-match .team.away {
    text-align: left;
  }

  /* ステージ行 */
  .match-schedule tr.stage-row td {
    background: #f8fafc;
    font-weight: 800;
    color: #3b82f6;
  }

  /* 試合済み */
  .match-schedule tr.played td {
    background: #fffdf3;
  }

  /* モバイル：列を減らして読みやすく */
  @media (max-width: 640px) {
    .match-schedule .col-st {
      display: none;
    }
    .match-schedule .col-sec {
      display: none;
    }

    /* 横スク前提で“最低幅”を与える（崩れ防止） */
    .match-schedule table.schedule {
      min-width: 720px;
    }
  }

  /* アンカーのズレ対策（ヘッダー固定用） */
  .match-schedule {
    scroll-margin-top: 72px;
  }
</style>

